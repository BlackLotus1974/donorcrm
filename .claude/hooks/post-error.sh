#!/bin/bash
# Self-improve rule - Claude adds its own rules for recurring bugs/patterns
# Enhanced with systematic debugging documentation

# Create rules directory if it doesn't exist
mkdir -p .claude/rules

# Include debugging documentation hook
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
if [[ -f "$SCRIPT_DIR/debugging-documentation.sh" ]]; then
    echo "=== Triggering Debugging Documentation Hook ==="
    bash "$SCRIPT_DIR/debugging-documentation.sh" "$@"
fi

# Function to add a new rule
add_rule() {
    local rule_file=".claude/rules/auto-generated-rules.md"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local rule_content="$1"
    
    # Create rules file if it doesn't exist
    if [[ ! -f "$rule_file" ]]; then
        cat > "$rule_file" << 'EOF'
# Auto-Generated Rules for Claude Code

This file contains rules automatically generated by Claude based on recurring patterns and errors encountered in this codebase.

---

EOF
    fi
    
    # Add the new rule
    echo "" >> "$rule_file"
    echo "## Rule Added: $timestamp" >> "$rule_file"
    echo "" >> "$rule_file"
    echo "$rule_content" >> "$rule_file"
    echo "" >> "$rule_file"
    echo "---" >> "$rule_file"
    echo "" >> "$rule_file"
}

# Check for common error patterns and suggest rules
if [[ -n "$CLAUDE_TOOL_ERROR" ]]; then
    error_message="$CLAUDE_TOOL_ERROR"
    
    # TypeScript/JavaScript patterns
    if [[ "$error_message" == *"Cannot find module"* ]] && [[ "$error_message" == *".ts"* ]]; then
        add_rule "**TypeScript Import Rule**: Always check if TypeScript files have proper file extensions in imports. Avoid missing .ts/.tsx extensions in relative imports."
    fi
    
    if [[ "$error_message" == *"Property does not exist on type"* ]]; then
        add_rule "**TypeScript Type Safety**: When encountering 'Property does not exist' errors, always check type definitions and consider using type assertions or optional chaining (?.) for safer property access."
    fi
    
    if [[ "$error_message" == *"npm ERR!"* ]] && [[ "$error_message" == *"ENOENT"* ]]; then
        add_rule "**npm Dependency Rule**: Before running npm scripts, always verify package.json exists and dependencies are installed. Run 'npm install' if needed."
    fi
    
    # Build/compilation patterns
    if [[ "$error_message" == *"Module not found"* ]] && [[ "$error_message" == *"tailwind"* ]]; then
        add_rule "**Tailwind CSS Rule**: When encountering Tailwind module errors, verify tailwind.config.js exists and Tailwind is properly configured in the build process."
    fi
    
    if [[ "$error_message" == *"Vite"* ]] && [[ "$error_message" == *"build failed"* ]]; then
        add_rule "**Vite Build Rule**: For Vite build failures, check vite.config.ts for proper configuration and ensure all environment variables are properly defined."
    fi
    
    # React patterns
    if [[ "$error_message" == *"hydration"* ]] || [[ "$error_message" == *"mismatch"* ]]; then
        add_rule "**React Hydration Rule**: Hydration mismatches often occur with dynamic content. Use useEffect for client-side only code and ensure server/client render the same initial content."
    fi
    
    # Generic patterns
    if [[ "$error_message" == *"Permission denied"* ]]; then
        add_rule "**File Permissions Rule**: When encountering permission errors, check file ownership and permissions. Use chmod/chown as needed, especially after git operations."
    fi
    
    if [[ "$error_message" == *"EACCES"* ]]; then
        add_rule "**npm Permission Rule**: EACCES errors often indicate npm permission issues. Consider using 'npm config set prefix' or running with appropriate permissions."
    fi
fi

# Check for recurring patterns in recently modified files
if [[ "$CLAUDE_TOOL_NAME" == "Edit" || "$CLAUDE_TOOL_NAME" == "Write" ]]; then
    file_path=$(echo "$CLAUDE_TOOL_ARGS_file_path" | tr -d '"')
    
    if [[ -n "$file_path" && -f "$file_path" ]]; then
        # Check for common patterns that might need rules
        
        # Check for TODO/FIXME comments
        if grep -q "TODO\|FIXME\|HACK" "$file_path" 2>/dev/null; then
            todo_count=$(grep -c "TODO\|FIXME\|HACK" "$file_path" 2>/dev/null || echo "0")
            if [[ "$todo_count" -gt 3 ]]; then
                add_rule "**Code Quality Rule**: File '$file_path' has $todo_count TODO/FIXME comments. Consider creating GitHub issues for these items and cleaning up temporary solutions."
            fi
        fi
        
        # Check for console.log in production code
        if [[ "$file_path" == *.ts || "$file_path" == *.tsx || "$file_path" == *.js || "$file_path" == *.jsx ]]; then
            if grep -q "console\.log\|console\.warn\|console\.error" "$file_path" 2>/dev/null; then
                add_rule "**Debug Logging Rule**: Found console statements in '$file_path'. Consider using a proper logging library or removing debug logs before production deployment."
            fi
        fi
        
        # Check for missing error handling
        if [[ "$file_path" == *.ts || "$file_path" == *.tsx ]]; then
            if grep -q "fetch\|axios\|http" "$file_path" 2>/dev/null && ! grep -q "catch\|try" "$file_path" 2>/dev/null; then
                add_rule "**Error Handling Rule**: File '$file_path' contains HTTP requests without visible error handling. Always wrap async operations in try-catch blocks."
            fi
        fi
    fi
fi